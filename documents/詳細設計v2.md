**0. 画面設計**
    週間タスクリストは、やりたいことカードのタイトルを修正するだけ
    以下、画面イメージ
    ![alt text](image.png)

## 1. 30秒要点（改訂版）

* **v1 のツール返却は「常に DashboardData 全体返却」**に固定します。UI の結合（マージ）コストを最小化し、`toolOutput` 更新に UI が追従するだけで整合します。`toolOutput` は **structuredContent そのもの**で、ホストが `openai:set_globals` で差し替える前提に合わせます。 ([OpenAI Developers][2])
* **readOnlyHint / destructiveHint** をツール定義に付与し、ChatGPT 側の確認フロー/誤操作防止に寄与させます（公式が推奨）。 ([OpenAI Developers][3])
* `analysisHistory` は **上限 N 件（v1: 20 件）**に制限します。`toolOutput`（＝structuredContent）はモデルが **そのまま読む**ため、肥大化を避けます。 ([OpenAI Developers][2])

---

## 2. v1 で先に固定する「ルール」（今回の修正で追加/明文化）

### 2.1 ツール返却ルール（最重要）

* **すべての主要ツールは `structuredContent: DashboardData` を返す**
  例外を作らないことで、UI は「最新の `toolOutput` を読む」だけになります。Quickstart の「レスポンスで UI を更新」パターンに沿いつつ、React では `toolOutput` 追従に寄せます。 ([OpenAI Developers][4])

### 2.2 structuredContent 肥大化防止

* `analysisHistory` は **最大 20 件**（`ANALYSIS_HISTORY_LIMIT = 20`）
* 追加で推奨：`Diary.content` は将来的に上限を検討（v1 では必須にしないが、`toolOutput` は “モデルが逐語で読む” ため、肥大化は常にリスク）。 ([OpenAI Developers][2])

### 2.3 ツールのアノテーション（UX/誤操作防止）

* `list_*` / `get_*` / `load_*` は `readOnlyHint: true`
* `delete_*` は `destructiveHint: true`
* それ以外の書き込み系は `destructiveHint: false`（「削除や上書き」ではないことを明示）
* `openWorldHint` は（外部公開しない想定なので）`false` を基本（公式のメタデータ最適化ガイドでも言及）。 ([OpenAI Developers][3])

### 2.4 Widget からツールを呼ぶルール（必須）

* UI（widget）から `window.openai.callTool` を使うツールは **`_meta["openai/widgetAccessible"]=true`** を付与します。 ([OpenAI Developers][5])
* モデルに触らせたくない “UI 操作専用” ツールは **`_meta["openai/visibility"]="private"`** を付与します（ウィジェットからは呼べる）。 ([OpenAI Developers][5])

### 2.5 UI の更新ルール（公式の更新イベントに追従）

* React は `openai:set_globals` を購読する `useOpenAiGlobal/useToolOutput`（公式例）を前提にし、**ツール呼び出し後は `toolOutput` 更新で再描画**させます。 ([OpenAI Developers][2])
* `window.openai.setWidgetState` は “モデルにも見える” ので、**UI の一時状態（入力途中など）を入れすぎない**（公式が注意喚起）。 ([OpenAI Developers][2])

---

## 3. 手順（詳細設計フルバージョン・改訂）

## 手順1：全体アーキテクチャ（v1）

### 1-1. 概要（3要素）

1. ChatGPT（Apps SDK）… ホスト（widget iframe を描画、`window.openai` を注入）
2. MCP サーバー（Node.js + TypeScript）… ツール/リソース（HTML）提供
3. SQLite … 永続ストレージ

Apps SDK は「ツール→structuredContent→UI（`window.openai.toolOutput`）」の流れを前提にしており、ツールのメタデータ（`openai/outputTemplate` など）が UI 表示と密接です。 ([OpenAI Developers][1])

### 1-2. 会話/描画フロー（確定）

1. モデル or UI がツールを呼ぶ
2. サーバーが DB を更新/取得し **DashboardData を返す**
3. ChatGPT が `openai/outputTemplate` の HTML（`text/html+skybridge`）を読み込み
4. ホストが `window.openai.toolOutput` を更新し、`openai:set_globals` を発火
5. UI は `toolOutput` を読んで再描画

この「注入と更新」は公式ガイドに明記されています。 ([OpenAI Developers][1])

---

## 手順2：ディレクトリ構成（“型の二重管理” を止める）

```text
project-root/
  server/
    server.ts                # MCP サーバー本体
    db.ts                    # SQLite 接続 + schema.sql 実行
    schema.sql               # テーブル定義
    repositories/            # DB アクセスまとめ
      diaryRepository.ts
      todoRepository.ts
      weeklyTaskRepository.ts
      analysisRepository.ts
    services/
      tagService.ts
      analysisService.ts
    tools/                  # MCP ツールのハンドラ集
      index.ts              # registerAllTools(server)
      dashboardTools.ts
      diaryTools.ts
      todoTools.ts
      weeklyTaskTools.ts
      analysisTools.ts
      helpers.ts
      buildDashboard.ts     # ★追加：DashboardData を必ず組み立てる唯一の関数
  ui/                       # フロント（React＋Apps SDK UI）
    index.html               # vite 等のエントリ
    src/
      main.tsx               # React エントリ
      App.tsx                # 全体レイアウト
      hooks/
        useOpenAiGlobal.ts  # ★追加（公式例準拠）
        useToolOutput.ts    # ★追加
      shared/               # ★追加：フロント専用の表示補助（任意）
      components/
        DiaryCard.tsx
        TodosCard.tsx
        WeeklyTasksCard.tsx
        AnalysisCard.tsx
  shared/
    types.ts                # ★追加：server/web で共用する唯一の型定義
  public/
    journal-widget.html     # ChatGPT が読み込むウィジェット HTML
```

**狙い**：`server/types.ts` と `web/types.ts` のコピペ運用を廃止し、**契約（contract）を 1 か所に固定**します。ツールは「契約」であり、メタデータ設計が重要と公式が述べています。 ([OpenAI Developers][3])

---

## 手順3：DB 詳細設計（schema.sql 改訂）

### 3-1. 変更点（v1必須）

* `analyses` に **ユニーク制約**（同一期間の二重保存を抑止）
* `analyses` の取得は **ORDER BY created_at DESC LIMIT N**（N=20）
* （任意だが推奨）`todos` / `weekly_tasks` に `client_id` を持たせ、**リトライに強い**追加を可能に（ツールはリトライされ得るため、可能なら冪等に寄せる）。 ([OpenAI Developers][1])

### 3-2. DDL（コピペ用・改訂）

```sql
-- diaries
CREATE TABLE IF NOT EXISTS diaries (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  date TEXT NOT NULL UNIQUE,              -- YYYY-MM-DD
  content TEXT NOT NULL DEFAULT '',
  tag1 TEXT, tag2 TEXT, tag3 TEXT, tag4 TEXT, tag5 TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- todos
CREATE TABLE IF NOT EXISTS todos (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  client_id TEXT UNIQUE,                  -- ★任意（推奨）：UIでUUID
  title TEXT NOT NULL,
  is_done INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- weekly_tasks
CREATE TABLE IF NOT EXISTS weekly_tasks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  client_id TEXT UNIQUE,                  -- ★任意（推奨）
  week_start_date TEXT NOT NULL,          -- YYYY-MM-DD
  title TEXT NOT NULL,
  is_done INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- analyses
CREATE TABLE IF NOT EXISTS analyses (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  period_type TEXT NOT NULL,              -- "week" | "month"
  start_date TEXT NOT NULL,
  end_date TEXT NOT NULL,
  summary TEXT NOT NULL,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(period_type, start_date, end_date)  -- ★v1必須：二重保存抑止
);
```

---

## 手順4：型定義（shared/types.ts に一本化・改訂）

### 4-1. 命名規則（v1固定）

* DB：snake_case
* API（structuredContent / UI）：camelCase
  （UI が扱いやすく、JS/TS と整合。Quickstart の JS 側も camelCase を前提に書かれています。） ([OpenAI Developers][4])

### 4-2. shared/types.ts（コピペ用・改訂）

```ts
export type Diary = {
  id: number;
  date: string;           // YYYY-MM-DD
  content: string;
  tags: string[];         // 最大5
  createdAt: string;
  updatedAt: string;
};

export type Todo = {
  id: number;
  clientId?: string;
  title: string;
  isDone: boolean;
  createdAt: string;
  updatedAt: string;
};

export type WeeklyTask = {
  id: number;
  clientId?: string;
  weekStartDate: string;  // YYYY-MM-DD
  title: string;
  isDone: boolean;
  createdAt: string;
  updatedAt: string;
};

export type Analysis = {
  id: number;
  periodType: "week" | "month";
  startDate: string;
  endDate: string;
  summary: string;
  createdAt: string;
};

export type AnalysisDraft = {
  periodType: "week" | "month";
  startDate: string;
  endDate: string;
  summary: string;
};

export type DashboardData = {
  view: {
    date: string;          // UIが表示している日付（サーバー確定値）
    weekStartDate: string; // UIが表示している週の開始日（サーバー確定値）
  };
  diary: Diary | null;
  todos: Todo[];
  weeklyTasks: WeeklyTask[];
  analysisDraft: AnalysisDraft | null;
  analysisHistory: Analysis[]; // ★最大N件
  suggestions?: {
    diaryTags?: string[];  // generate_diary_tags 用（未保存）
  };
};
```

---

## 手順5：サーバー内部構造（repositories / services / tools）

### 5-1. buildDashboard.ts（★v1の要）

**どのツールでも最後は必ずこれを呼んで DashboardData を返す**。
structuredContent はモデルが逐語で読むため、ここで “サイズ制御（analysisHistory の limit）” を強制します。 ([OpenAI Developers][2])

```ts
import type { DashboardData } from "../../shared/types";
import * as diaryRepo from "../repositories/diaryRepository";
import * as todoRepo from "../repositories/todoRepository";
import * as weeklyRepo from "../repositories/weeklyTaskRepository";
import * as analysisRepo from "../repositories/analysisRepository";

export const ANALYSIS_HISTORY_LIMIT = 20;

function toIsoDate(d: Date) {
  return d.toISOString().slice(0, 10);
}

// 例：日曜始まりにしたいならここで統一（v1固定）
export function getWeekStartDate(date: string) {
  const d = new Date(date + "T00:00:00Z");
  const day = d.getUTCDay(); // 0=Sun
  d.setUTCDate(d.getUTCDate() - day);
  return toIsoDate(d);
}

export async function buildDashboard(params: {
  viewDate?: string;
  suggestions?: DashboardData["suggestions"];
  analysisDraft?: DashboardData["analysisDraft"];
}): Promise<DashboardData> {
  const date = params.viewDate ?? toIsoDate(new Date());
  const weekStartDate = getWeekStartDate(date);

  const [diary, todos, weeklyTasks, analysisHistory] = await Promise.all([
    diaryRepo.getDiaryByDate(date),
    todoRepo.listTodos(),
    weeklyRepo.listWeeklyTasks({ weekStartDate }),
    analysisRepo.getLatestAnalyses(ANALYSIS_HISTORY_LIMIT),
  ]);

  return {
    view: { date, weekStartDate },
    diary,
    todos,
    weeklyTasks,
    analysisDraft: params.analysisDraft ?? null,
    analysisHistory,
    suggestions: params.suggestions,
  };
}
```

### 5-2. tools/helpers.ts（DashboardData専用に簡素化）

```ts
import type { DashboardData } from "../../shared/types";

type TextContent = { type: "text"; text: string };

export function replyDashboard(message: string | null, data: DashboardData) {
  const content: TextContent[] = message ? [{ type: "text", text: message }] : [];
  return { content, structuredContent: data };
}
```

---

## 手順6：MCP ツール設計（全体返却 + hints + widgetAccessible + private）

### 6-1. ツールメタ（公式の必須フィールド）

* `_meta["openai/outputTemplate"]`：UI テンプレ URI（`text/html+skybridge` の resource） ([OpenAI Developers][5])
* `_meta["openai/widgetAccessible"]`：widget→tool を許可する（UI 操作に必須） ([OpenAI Developers][5])
* `_meta["openai/visibility"]`：モデルから隠す（UI 専用は private） ([OpenAI Developers][5])

### 6-2. ツール一覧（v1確定：すべて DashboardData を返す）

#### A. 共通

1. `load_dashboard`（readOnly）

* 入力：`{ viewDate?: string }`
* annotations：`readOnlyHint: true`
* visibility：`public`（モデルも起動してよい）
* 出力：DashboardData

#### B. 日記

2. `save_diary`（write）

* 入力：`{ viewDate?: string; date: string; content: string; tags?: string[] }`
* tags 未指定時はサーバーで生成してよい（v1運用）
* 出力：DashboardData

3. `generate_diary_tags`（readOnly だが “提案生成”）

* 入力：`{ viewDate?: string; content: string }`
* 出力：DashboardData（`suggestions.diaryTags` に格納、DB 保存しない）

#### C. Todo

4. `add_todo`（write）

* 入力：`{ viewDate?: string; title: string; clientId?: string }`
* 出力：DashboardData

5. `set_todo_done`（write）

* 入力：`{ viewDate?: string; id: number; isDone: boolean }`
* 出力：DashboardData

6. `delete_todo`（destructive）

* 入力：`{ viewDate?: string; id: number }`
* annotations：`destructiveHint: true`
* 出力：DashboardData

#### D. 週間タスク

7. `add_weekly_task`（write）

* 入力：`{ viewDate?: string; weekStartDate?: string; title: string; clientId?: string }`
* weekStartDate 未指定なら `viewDate` から計算（buildDashboard と同一関数で統一）
* 出力：DashboardData

8. `set_weekly_task_done`（write）

* 入力：`{ viewDate?: string; id: number; isDone: boolean }`
* 出力：DashboardData

9. `delete_weekly_task`（destructive）

* 入力：`{ viewDate?: string; id: number }`
* annotations：`destructiveHint: true`
* 出力：DashboardData

#### E. 行動分析

10. `run_analysis`（writeではないが生成）

* 入力：`{ viewDate?: string; periodType: "week"|"month"; startDate: string }`
* DB には保存しない（draft を返すだけ）
* 出力：DashboardData（`analysisDraft` に格納）

11. `save_analysis`（write）

* 入力：`AnalysisDraft & { viewDate?: string }`
* 出力：DashboardData（analysisHistory は **最大 20** のまま）

> 補足：`list_*` / `get_*` の個別ツールは v1 では “全体返却” 方針と役割が重複しがちです。残す場合も返却は DashboardData に統一し、readOnlyHint を付けます（公式推奨）。 ([OpenAI Developers][3])

---

## 手順7：server.ts（重要箇所だけ改訂例）

### 7-1. registerTool の共通テンプレ（推奨）

`outputTemplate / widgetAccessible / visibility` を書き忘れる事故を防ぎます。これらは Reference にまとまっています。 ([OpenAI Developers][5])

```ts
const OUTPUT_TEMPLATE = "ui://widget/journal.html";

function toolMeta(params: {
  invoking: string;
  invoked: string;
  widgetAccessible?: boolean;
  visibility?: "public" | "private";
}) {
  return {
    "openai/outputTemplate": OUTPUT_TEMPLATE,
    "openai/toolInvocation/invoking": params.invoking,
    "openai/toolInvocation/invoked": params.invoked,
    ...(params.widgetAccessible ? { "openai/widgetAccessible": true } : {}),
    ...(params.visibility ? { "openai/visibility": params.visibility } : {}),
  };
}
```

### 7-2. `load_dashboard` の改訂例（readOnlyHint + 全体返却）

```ts
server.registerTool(
  "load_dashboard",
  {
    title: "Load dashboard",
    description: "Use this when you need the latest diary/todos/weekly tasks/analysis history for a date.",
    inputSchema: { viewDate: z.string().optional() },
    annotations: { readOnlyHint: true, openWorldHint: false },
    _meta: toolMeta({
      invoking: "ダッシュボードを読み込み中...",
      invoked: "ダッシュボードを読み込みました",
      widgetAccessible: true,
      visibility: "public",
    }),
  },
  async (args) => {
    const data = await buildDashboard({ viewDate: args?.viewDate });
    return replyDashboard(null, data);
  }
);
```

### 7-3. `delete_todo` の改訂例（destructiveHint + private 推奨）

削除系は誤操作防止のため destructiveHint を付与（公式が推奨）。また UI 操作専用なら private でモデルに見せないのが安全です。 ([OpenAI Developers][3])

```ts
server.registerTool(
  "delete_todo",
  {
    title: "Delete todo",
    description: "Use this when the user explicitly wants to delete a todo item.",
    inputSchema: { viewDate: z.string().optional(), id: z.number().int() },
    annotations: { destructiveHint: true, openWorldHint: false },
    _meta: toolMeta({
      invoking: "Todoを削除中...",
      invoked: "Todoを削除しました",
      widgetAccessible: true,
      visibility: "private",
    }),
  },
  async (args) => {
    await todoRepo.deleteTodo(args.id);
    const data = await buildDashboard({ viewDate: args.viewDate });
    return replyDashboard(null, data);
  }
);
```

### 7-4. HTTP ルーティング（/mcp と /mcp/actions を確実に拾う）

Quickstart は “/mcp と nested routes（例：/mcp/actions）” を意識する旨を明記しています。 ([OpenAI Developers][4])
そのため判定は `===` ではなく `startsWith` を推奨します。

---

## 手順8：フロントエンド（React + Apps SDK UI）改訂

### 8-1. `toolOutput` 追従（公式の `openai:set_globals` を使う）

公式は `openai:set_globals` を購読する `useOpenAiGlobal` を例示し、`toolOutput`/`toolInput` を hook 化する方針を示しています。 ([OpenAI Developers][2])

#### `web/src/hooks/useOpenAiGlobal.ts`

```ts
import { useSyncExternalStore } from "react";

const SET_GLOBALS_EVENT_TYPE = "openai:set_globals";

type SetGlobalsEvent = CustomEvent<{ globals: any }>;

export function useOpenAiGlobal<T = any>(key: string): T | undefined {
  return useSyncExternalStore(
    (onChange) => {
      const handle = (event: Event) => {
        const e = event as SetGlobalsEvent;
        if (e.detail?.globals?.[key] === undefined) return;
        onChange();
      };
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handle, { passive: true });
      return () => window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handle);
    },
    () => (window as any).openai?.[key]
  );
}

export function useToolOutput<T = any>() {
  return useOpenAiGlobal<T>("toolOutput");
}
```

### 8-2. App.tsx（“全体返却” 前提の state 設計）

* `serverData`：`toolOutput`（DashboardData）そのもの
* `draft`：入力途中のローカル state（widgetState に入れない）
  ※ `setWidgetState` はモデルにも見えるため、入れすぎ注意。 ([OpenAI Developers][2])

```tsx
import { useEffect, useMemo, useState } from "react";
import type { DashboardData } from "../../shared/types";
import { useToolOutput } from "./hooks/useOpenAiGlobal";

export function JournalCoachApp() {
  const toolOutput = useToolOutput<DashboardData>();
  const serverData = toolOutput;

  const [draftDiary, setDraftDiary] = useState({ content: "", tags: [] as string[] });

  // サーバーの表示日付が変わったら draft を初期化（保存後/日付変更後に自然に追従）
  useEffect(() => {
    const diary = serverData?.diary;
    setDraftDiary({
      content: diary?.content ?? "",
      tags: diary?.tags ?? [],
    });
  }, [serverData?.view?.date, serverData?.diary?.updatedAt]);

  const callTool = async (name: string, args: any) => {
    if (!(window as any).openai?.callTool) return;
    await (window as any).openai.callTool(name, args);
    // 返り値で setState しない：toolOutput 更新（set_globals）に任せる
  };

  const viewDate = serverData?.view?.date;

  return (
    <div className="flex flex-col gap-4 p-2">
      {/* 例：日記保存 */}
      <button
        onClick={() =>
          callTool("save_diary", {
            viewDate,
            date: viewDate,
            content: draftDiary.content,
            tags: draftDiary.tags,
          })
        }
      >
        保存
      </button>
    </div>
  );
}
```

---

# 4. 今回「修正した部分」の解説（なぜ必要か）

1. **ツール返却を DashboardData “全体返却” に統一**
   `toolOutput` は structuredContent そのもので、UI は `openai:set_globals` で更新を受けます。ここを部分返却＋UIマージにすると、結合ロジックが増え、バグ温床になります。v1 は全体返却が結合コスト最小です。 ([OpenAI Developers][2])

2. **UI は `useToolOutput`（= openai:set_globals 購読）前提に変更**
   公式が `openai:set_globals` を購読する hook を例示しており、React ではこの購読が最も事故りません。 ([OpenAI Developers][2])

3. **`readOnlyHint` / `destructiveHint` を設計に組み込み**
   公式の「Define tools」「Optimize metadata」で、readOnly/destructive/openWorld のヒント付与が推奨されています。削除系は destructiveHint を必ず付ける、一覧/取得は readOnlyHint を付ける、をルール化しました。 ([OpenAI Developers][3])

4. **`analysisHistory` を上限 N（v1=20）に制限**
   `toolOutput` は「モデルが逐語で読む」ため、肥大化は性能/挙動の両面で不利です。まずは履歴を “直近 N” に切り、必要なら別導線（ページング等）を v2 で検討するのが安全です。 ([OpenAI Developers][2])

5. **widget→tool 呼び出しのため `openai/widgetAccessible` を必須化**
   UI から `window.openai.callTool` を使うには、ツール側で widgetAccessible を明示する必要があります（Reference に明記）。 ([OpenAI Developers][5])

## 手順9：全ツールの `registerTool` 実装（コピペ用・v1全体返却版）

ここでは **Apps SDK 公式の Tool descriptor / `_meta` / `annotations`** の仕様に合わせて、ツール登録をファイル分割しつつ **すべてのツールが `DashboardData` を丸ごと返す**ように実装します。`_meta["openai/outputTemplate"]`、`_meta["openai/widgetAccessible"]`、`_meta["openai/visibility"]`、`openai/toolInvocation/*`、および `annotations`（`readOnlyHint`/`destructiveHint`/`openWorldHint`）は公式 Reference に準拠しています。 ([OpenAI Developers][1])

---

### 9-0. 前提（この手順が依存する既存ファイル）

* `shared/types.ts`（DashboardData/Diary/Todo/WeeklyTask/Analysis/AnalysisDraft）
* `server/tools/helpers.ts`（`replyDashboard`）
* `server/tools/buildDashboard.ts`（`buildDashboard` と `ANALYSIS_HISTORY_LIMIT`）
* repositories/services（呼び出し先）

> `toolOutput` は `window.openai.toolOutput` に入り、`openai:set_globals` で更新されます（UI 側は購読して追従）。 ([OpenAI Developers][2])

---

## 9-1. 共通ユーティリティ（必須）

### `server/tools/tooling.ts`

```ts
import { z } from "zod";

/**
 * Apps SDK Reference:
 * - _meta["openai/outputTemplate"] は text/html+skybridge の Resource URI
 * - _meta["openai/widgetAccessible"] は widget→tool 呼び出し許可
 * - _meta["openai/visibility"] は public/private（privateでもwidgetからは呼べる）
 * - annotations は readOnlyHint/destructiveHint/openWorldHint を使う
 */
export const OUTPUT_TEMPLATE = "ui://widget/journal.html";

// YYYY-MM-DD の軽いバリデーション（厳密な暦までは見ない）
export const zIsoDate = z.string().regex(/^\d{4}-\d{2}-\d{2}$/);

export const zViewDate = zIsoDate.optional();

export function meta(params: {
  invoking: string;
  invoked: string;
  widgetAccessible?: boolean; // default true（v1方針）
  visibility?: "public" | "private";
}) {
  return {
    "openai/outputTemplate": OUTPUT_TEMPLATE,
    "openai/toolInvocation/invoking": params.invoking.slice(0, 64),
    "openai/toolInvocation/invoked": params.invoked.slice(0, 64),
    ...(params.widgetAccessible === false ? {} : { "openai/widgetAccessible": true }),
    ...(params.visibility ? { "openai/visibility": params.visibility } : {}),
  } as const;
}

// Reference の annotations（3つとも宣言する）
export function ann(params: {
  readOnly: boolean;
  destructive: boolean;
  openWorld?: boolean;
}) {
  return {
    readOnlyHint: params.readOnly,
    destructiveHint: params.destructive,
    openWorldHint: params.openWorld ?? false,
  } as const;
}
```

（`_meta` と `annotations` のキー/意味は公式 Reference と Define tools に準拠） ([OpenAI Developers][1])

---

## 9-2. ツール一括登録エントリ

### `server/tools/index.ts`

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

import { registerDashboardTools } from "./dashboardTools";
import { registerDiaryTools } from "./diaryTools";
import { registerTodoTools } from "./todoTools";
import { registerWeeklyTaskTools } from "./weeklyTaskTools";
import { registerAnalysisTools } from "./analysisTools";

export function registerAllTools(server: McpServer) {
  registerDashboardTools(server);
  registerDiaryTools(server);
  registerTodoTools(server);
  registerWeeklyTaskTools(server);
  registerAnalysisTools(server);
}
```

---

## 9-3. Dashboard ツール

### `server/tools/dashboardTools.ts`

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

import { replyDashboard } from "./helpers";
import { buildDashboard } from "./buildDashboard";
import { ann, meta, zViewDate } from "./tooling";

export function registerDashboardTools(server: McpServer) {
  server.registerTool(
    "load_dashboard",
    {
      title: "Load dashboard",
      description:
        "Use this when you need the latest dashboard data (diary, todos, weekly tasks, analysis history) for a given date.",
      inputSchema: { viewDate: zViewDate },
      annotations: ann({ readOnly: true, destructive: false, openWorld: false }),
      _meta: meta({
        invoking: "ダッシュボードを読み込み中...",
        invoked: "ダッシュボードを読み込みました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const data = await buildDashboard({ viewDate: args?.viewDate });
      return replyDashboard(null, data);
    }
  );
}
```

（ツール設計の「Use this when…」は公式のメタデータ設計ガイドに沿う） ([OpenAI Developers][3])

---

## 9-4. 日記ツール

### `server/tools/diaryTools.ts`

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

import { replyDashboard } from "./helpers";
import { buildDashboard } from "./buildDashboard";
import { ann, meta, zIsoDate, zViewDate } from "./tooling";

import * as diaryRepo from "../repositories/diaryRepository";
import { generateTagsFromContent } from "../services/tagService";

export function registerDiaryTools(server: McpServer) {
  // get_diary_by_date（read-only）
  server.registerTool(
    "get_diary_by_date",
    {
      title: "Get diary by date",
      description: "Use this when you need to display the diary entry for a specific date.",
      inputSchema: { date: zIsoDate, viewDate: zViewDate },
      annotations: ann({ readOnly: true, destructive: false }),
      _meta: meta({
        invoking: "日記を読み込み中...",
        invoked: "日記を読み込みました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const viewDate = args?.date ?? args?.viewDate;
      const data = await buildDashboard({ viewDate });
      return replyDashboard(null, data);
    }
  );

  // save_diary（v1: tags未指定ならサーバーで生成して保存してもよい）
  server.registerTool(
    "save_diary",
    {
      title: "Save diary",
      description: "Use this when the user wants to create or update a diary entry for a date.",
      inputSchema: {
        viewDate: zViewDate,
        date: zIsoDate,
        content: z.string().default(""),
        tags: z.array(z.string().min(1)).max(5).optional(),
      },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "日記を保存中...",
        invoked: "日記を保存しました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const date = args.date;
      const content = (args.content ?? "").toString();
      const tags =
        args.tags && args.tags.length > 0
          ? args.tags.slice(0, 5)
          : (await generateTagsFromContent(content)).slice(0, 5);

      await diaryRepo.upsertDiary({ date, content, tags });

      const data = await buildDashboard({ viewDate: args.viewDate ?? date });
      return replyDashboard("日記を保存しました。", data);
    }
  );

  // update_diary_content（UI専用：private推奨）
  server.registerTool(
    "update_diary_content",
    {
      title: "Update diary content",
      description: "Use this when the widget updates only the diary content field for a date.",
      inputSchema: { viewDate: zViewDate, date: zIsoDate, content: z.string().default("") },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "本文を更新中...",
        invoked: "本文を更新しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await diaryRepo.updateDiaryContent({ date: args.date, content: args.content ?? "" });
      const data = await buildDashboard({ viewDate: args.viewDate ?? args.date });
      return replyDashboard(null, data);
    }
  );

  // update_diary_tags（UI専用：private推奨）
  server.registerTool(
    "update_diary_tags",
    {
      title: "Update diary tags",
      description: "Use this when the widget updates only the diary tags for a date.",
      inputSchema: { viewDate: zViewDate, date: zIsoDate, tags: z.array(z.string().min(1)).max(5) },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "タグを更新中...",
        invoked: "タグを更新しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await diaryRepo.updateDiaryTags({ date: args.date, tags: args.tags.slice(0, 5) });
      const data = await buildDashboard({ viewDate: args.viewDate ?? args.date });
      return replyDashboard(null, data);
    }
  );

  // generate_diary_tags（保存しない：suggestionsに載せる）
  server.registerTool(
    "generate_diary_tags",
    {
      title: "Generate diary tags",
      description: "Use this when the user wants tag suggestions for the current diary content.",
      inputSchema: { viewDate: zViewDate, content: z.string().default("") },
      annotations: ann({ readOnly: true, destructive: false }),
      _meta: meta({
        invoking: "タグ候補を生成中...",
        invoked: "タグ候補を生成しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      const tags = (await generateTagsFromContent(args.content ?? "")).slice(0, 5);
      const data = await buildDashboard({
        viewDate: args.viewDate,
        suggestions: { diaryTags: tags },
      });
      return replyDashboard(null, data);
    }
  );
}
```

* `_meta["openai/visibility"]="private"` は「モデルから隠しつつ widget から呼べる」公式仕様に準拠。 ([OpenAI Developers][1])
* readOnly/destructive/openWorld のヒントは公式で推奨。 ([OpenAI Developers][3])

---

## 9-5. Todo ツール

### `server/tools/todoTools.ts`

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

import { replyDashboard } from "./helpers";
import { buildDashboard } from "./buildDashboard";
import { ann, meta, zViewDate } from "./tooling";

import * as todoRepo from "../repositories/todoRepository";

export function registerTodoTools(server: McpServer) {
  // list_todos（read-only）
  server.registerTool(
    "list_todos",
    {
      title: "List todos",
      description: "Use this when you need to show the current todo list.",
      inputSchema: { viewDate: zViewDate },
      annotations: ann({ readOnly: true, destructive: false }),
      _meta: meta({
        invoking: "Todoを読み込み中...",
        invoked: "Todoを読み込みました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const data = await buildDashboard({ viewDate: args?.viewDate });
      return replyDashboard(null, data);
    }
  );

  // add_todo（作成はpublic）
  server.registerTool(
    "add_todo",
    {
      title: "Add todo",
      description: "Use this when the user wants to add a new todo item.",
      inputSchema: {
        viewDate: zViewDate,
        title: z.string().min(1),
        clientId: z.string().optional(), // 冪等化のため任意
      },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "Todoを追加中...",
        invoked: "Todoを追加しました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      await todoRepo.addTodo({ title: args.title, clientId: args.clientId });
      const data = await buildDashboard({ viewDate: args.viewDate });
      return replyDashboard("Todoを追加しました。", data);
    }
  );

  // set_todo_done（UI専用：private推奨）
  server.registerTool(
    "set_todo_done",
    {
      title: "Set todo done",
      description: "Use this when the widget toggles completion for a todo item.",
      inputSchema: { viewDate: zViewDate, id: z.number().int().positive(), isDone: z.boolean() },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "状態を更新中...",
        invoked: "状態を更新しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await todoRepo.setTodoDone({ id: args.id, isDone: args.isDone });
      const data = await buildDashboard({ viewDate: args.viewDate });
      return replyDashboard(null, data);
    }
  );

  // delete_todo（destructiveHint）
  server.registerTool(
    "delete_todo",
    {
      title: "Delete todo",
      description: "Use this when the user explicitly wants to delete a todo item.",
      inputSchema: { viewDate: zViewDate, id: z.number().int().positive() },
      annotations: ann({ readOnly: false, destructive: true }),
      _meta: meta({
        invoking: "Todoを削除中...",
        invoked: "Todoを削除しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await todoRepo.deleteTodo(args.id);
      const data = await buildDashboard({ viewDate: args.viewDate });
      return replyDashboard("Todoを削除しました。", data);
    }
  );
}
```

（`destructiveHint`/`readOnlyHint` は公式の annotations として規定） ([OpenAI Developers][1])

---

## 9-6. 週間タスク ツール

### `server/tools/weeklyTaskTools.ts`

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

import { replyDashboard } from "./helpers";
import { buildDashboard, getWeekStartDate } from "./buildDashboard";
import { ann, meta, zIsoDate, zViewDate } from "./tooling";

import * as weeklyRepo from "../repositories/weeklyTaskRepository";

export function registerWeeklyTaskTools(server: McpServer) {
  // list_weekly_tasks（read-only）
  server.registerTool(
    "list_weekly_tasks",
    {
      title: "List weekly tasks",
      description: "Use this when you need to show weekly tasks for the current week.",
      inputSchema: { viewDate: zViewDate },
      annotations: ann({ readOnly: true, destructive: false }),
      _meta: meta({
        invoking: "週間タスクを読み込み中...",
        invoked: "週間タスクを読み込みました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const data = await buildDashboard({ viewDate: args?.viewDate });
      return replyDashboard(null, data);
    }
  );

  // add_weekly_task（作成はpublic）
  server.registerTool(
    "add_weekly_task",
    {
      title: "Add weekly task",
      description: "Use this when the user wants to add a weekly task.",
      inputSchema: {
        viewDate: zViewDate,
        weekStartDate: zIsoDate.optional(), // 未指定ならviewDateから計算
        title: z.string().min(1),
        clientId: z.string().optional(),
      },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "週間タスクを追加中...",
        invoked: "週間タスクを追加しました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const viewDate = args.viewDate;
      const weekStartDate = args.weekStartDate ?? (viewDate ? getWeekStartDate(viewDate) : undefined);
      if (!weekStartDate) {
        // viewDateもweekStartDateも無い場合はbuildDashboardに任せる（today起点）:
        const data = await buildDashboard({ viewDate });
        return replyDashboard("週の開始日が決められませんでした。", data);
      }

      await weeklyRepo.addWeeklyTask({
        weekStartDate,
        title: args.title,
        clientId: args.clientId,
      });

      const data = await buildDashboard({ viewDate: viewDate ?? weekStartDate });
      return replyDashboard("週間タスクを追加しました。", data);
    }
  );

  // set_weekly_task_done（UI専用：private推奨）
  server.registerTool(
    "set_weekly_task_done",
    {
      title: "Set weekly task done",
      description: "Use this when the widget toggles completion for a weekly task item.",
      inputSchema: { viewDate: zViewDate, id: z.number().int().positive(), isDone: z.boolean() },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "状態を更新中...",
        invoked: "状態を更新しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await weeklyRepo.setWeeklyTaskDone({ id: args.id, isDone: args.isDone });
      const data = await buildDashboard({ viewDate: args.viewDate });
      return replyDashboard(null, data);
    }
  );

  // delete_weekly_task（destructiveHint）
  server.registerTool(
    "delete_weekly_task",
    {
      title: "Delete weekly task",
      description: "Use this when the user explicitly wants to delete a weekly task item.",
      inputSchema: { viewDate: zViewDate, id: z.number().int().positive() },
      annotations: ann({ readOnly: false, destructive: true }),
      _meta: meta({
        invoking: "週間タスクを削除中...",
        invoked: "週間タスクを削除しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await weeklyRepo.deleteWeeklyTask(args.id);
      const data = await buildDashboard({ viewDate: args.viewDate });
      return replyDashboard("週間タスクを削除しました。", data);
    }
  );
}
```

---

## 9-7. 行動分析 ツール

### `server/tools/analysisTools.ts`

```ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

import { replyDashboard } from "./helpers";
import { buildDashboard } from "./buildDashboard";
import { ann, meta, zIsoDate, zViewDate } from "./tooling";

import * as diaryRepo from "../repositories/diaryRepository";
import * as analysisRepo from "../repositories/analysisRepository";
import { runBehaviorAnalysis } from "../services/analysisService";

function addDays(start: string, days: number) {
  const d = new Date(start + "T00:00:00Z");
  d.setUTCDate(d.getUTCDate() + days);
  return d.toISOString().slice(0, 10);
}

function computeEndDate(periodType: "week" | "month", startDate: string) {
  if (periodType === "week") return addDays(startDate, 6);
  // month: startDateの月末（簡易）= 翌月1日 - 1日
  const d = new Date(startDate + "T00:00:00Z");
  const y = d.getUTCFullYear();
  const m = d.getUTCMonth(); // 0-11
  const firstNext = new Date(Date.UTC(y, m + 1, 1));
  firstNext.setUTCDate(firstNext.getUTCDate() - 1);
  return firstNext.toISOString().slice(0, 10);
}

export function registerAnalysisTools(server: McpServer) {
  // run_analysis（生成：draftをDashboardに載せる）
  server.registerTool(
    "run_analysis",
    {
      title: "Run analysis",
      description: "Use this when the user wants an AI-written analysis for a period starting at startDate.",
      inputSchema: {
        viewDate: zViewDate,
        periodType: z.enum(["week", "month"]),
        startDate: zIsoDate,
      },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "分析を生成中...",
        invoked: "分析を生成しました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const endDate = computeEndDate(args.periodType, args.startDate);
      const diaries = await diaryRepo.listDiariesInRange({
        startDate: args.startDate,
        endDate,
      });

      const result = await runBehaviorAnalysis({
        periodType: args.periodType,
        startDate: args.startDate,
        diaries,
      });

      const data = await buildDashboard({
        viewDate: args.viewDate ?? args.startDate,
        analysisDraft: {
          periodType: args.periodType,
          startDate: args.startDate,
          endDate: result.endDate ?? endDate,
          summary: result.summary,
        },
      });

      return replyDashboard(null, data);
    }
  );

  // save_analysis（保存：destructiveではないが書き込み。UI専用ならprivate推奨）
  server.registerTool(
    "save_analysis",
    {
      title: "Save analysis",
      description: "Use this when the user confirms they want to save the generated analysis result.",
      inputSchema: {
        viewDate: zViewDate,
        periodType: z.enum(["week", "month"]),
        startDate: zIsoDate,
        endDate: zIsoDate,
        summary: z.string().min(1),
      },
      annotations: ann({ readOnly: false, destructive: false }),
      _meta: meta({
        invoking: "分析を保存中...",
        invoked: "分析を保存しました",
        widgetAccessible: true,
        visibility: "private",
      }),
    },
    async (args) => {
      await analysisRepo.createAnalysis({
        periodType: args.periodType,
        startDate: args.startDate,
        endDate: args.endDate,
        summary: args.summary,
      });

      const data = await buildDashboard({
        viewDate: args.viewDate ?? args.startDate,
        analysisDraft: null,
      });

      return replyDashboard("分析を保存しました。", data);
    }
  );

  // list_analyses（read-only：ただし返すのはDashboardDataで、historyはlimit済み）
  server.registerTool(
    "list_analyses",
    {
      title: "List analyses",
      description: "Use this when you need to show recent analysis history.",
      inputSchema: { viewDate: zViewDate },
      annotations: ann({ readOnly: true, destructive: false }),
      _meta: meta({
        invoking: "分析履歴を読み込み中...",
        invoked: "分析履歴を読み込みました",
        widgetAccessible: true,
        visibility: "public",
      }),
    },
    async (args) => {
      const data = await buildDashboard({ viewDate: args?.viewDate });
      return replyDashboard(null, data);
    }
  );
}
```

---

## 9-8. `server/server.ts` 側の呼び出し（差分）

`createJournalCoachServer()` の中で、個別 `registerTool` を直書きせず、`registerAllTools(server)` に置き換えます。MCP サーバーは「ツールとテンプレートを結び、UI とモデルとサーバーの境界を明確にする」という公式の説明に沿う構成です。 ([OpenAI Developers][4])

```ts
import { registerAllTools } from "./tools";

function createJournalCoachServer() {
  const server = new McpServer({ name: "journal-coach", version: "0.1.0" });

  // registerResource(...) はこれまで通り

  registerAllTools(server);
  return server;
}
```


[1]: https://developers.openai.com/apps-sdk/build/mcp-server/ "Build your MCP server"
[2]: https://developers.openai.com/apps-sdk/build/chatgpt-ui/ "Build your ChatGPT UI"
[3]: https://developers.openai.com/apps-sdk/plan/tools/ "Define tools"
[4]: https://developers.openai.com/apps-sdk/quickstart/ "Quickstart"
[5]: https://developers.openai.com/apps-sdk/reference/ "Reference"
